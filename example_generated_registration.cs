// <auto-generated/>
#pragma warning disable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using Microsoft.Extensions.AI;
using System.Linq;
using System.Text;
using Json.Schema;
using Json.Schema.Generation;

/// <summary>
/// Represents the arguments for the Add function, generated at compile-time.
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("HPDPluginSourceGenerator", "1.0.0.0")]
public class AddArgs
{
    [System.Text.Json.Serialization.JsonPropertyName("a")]
    public decimal A { get; set; } = default!;
    [System.Text.Json.Serialization.JsonPropertyName("b")]
    public decimal B { get; set; } = default!;
}

/// <summary>
/// Represents the arguments for the Multiply function, generated at compile-time.
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("HPDPluginSourceGenerator", "1.0.0.0")]
public class MultiplyArgs
{
    [System.Text.Json.Serialization.JsonPropertyName("a")]
    public long A { get; set; } = default!;
    [System.Text.Json.Serialization.JsonPropertyName("b")]
    public long B { get; set; } = default!;
}

/// <summary>
/// Represents the arguments for the Abs function, generated at compile-time.
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("HPDPluginSourceGenerator", "1.0.0.0")]
public class AbsArgs
{
    [System.Text.Json.Serialization.JsonPropertyName("value")]
    public long Value { get; set; } = default!;
}

/// <summary>
/// Generated registration code for MathPlugin plugin.
/// </summary>
[System.CodeDom.Compiler.GeneratedCodeAttribute("HPDPluginSourceGenerator", "1.0.0.0")]
public static partial class MathPluginRegistration
{
    /// <summary>
    /// Creates an AIFunction list for the MathPlugin plugin.
    /// </summary>
    /// <param name="instance">The plugin instance</param>
    /// <param name="context">The execution context (optional)</param>
    public static List<AIFunction> CreatePlugin(MathPlugin instance, IPluginMetadataContext? context = null)
    {
        var functions = new List<AIFunction>();

        // Always included functions
        functions.Add(HPDAIFunctionFactory.Create(
            new Func<AIFunctionArguments, CancellationToken, Task<object?>>(async (arguments, cancellationToken) =>
            {
                var jsonArgs = arguments.GetJson();
                var args = ParseAddArgs(jsonArgs);
                return (await instance.Add(args.A, args.B)) as object;
            }),
            new HPDAIFunctionFactoryOptions
            { 
                Name = "Add",
                Description = "Adds two numbers and returns the sum.",
                RequiresPermission = true,
                Validator = CreateAddValidator(),
                SchemaProvider = () => { 
                    var schema = new Json.Schema.JsonSchemaBuilder().FromType<AddArgs>().Build();
                    var schemaJson = JsonSerializer.Serialize(schema, HPDJsonContext.Default.JsonSchema);
                    var node = JsonNode.Parse(schemaJson);
                    if (node is JsonObject root && root["properties"] is JsonObject properties)
                    {
                        if (properties["a"] is JsonObject aObj)
                        {
                            aObj["description"] = "First addend.";
                        }
                        if (properties["b"] is JsonObject bObj)
                        {
                            bObj["description"] = "Second addend.";
                        }
                    }
                    return JsonSerializer.SerializeToElement(node ?? JsonNode.Parse("{}"), HPDJsonContext.Default.JsonNode);
                 },
                ParameterDescriptions = new Dictionary<string, string> {
                    { "a", "First addend." },
                    { "b", "Second addend." }
                }
            }
        ));

        functions.Add(HPDAIFunctionFactory.Create(
            new Func<AIFunctionArguments, CancellationToken, Task<object?>>(async (arguments, cancellationToken) =>
            {
                var jsonArgs = arguments.GetJson();
                var args = ParseMultiplyArgs(jsonArgs);
                return (await instance.Multiply(args.A, args.B)) as object;
            }),
            new HPDAIFunctionFactoryOptions
            { 
                Name = "Multiply",
                Description = "Multiplies two numbers and returns the product.",
                RequiresPermission = false,
                Validator = CreateMultiplyValidator(),
                SchemaProvider = () => { 
                    var schema = new Json.Schema.JsonSchemaBuilder().FromType<MultiplyArgs>().Build();
                    var schemaJson = JsonSerializer.Serialize(schema, HPDJsonContext.Default.JsonSchema);
                    var node = JsonNode.Parse(schemaJson);
                    if (node is JsonObject root && root["properties"] is JsonObject properties)
                    {
                        if (properties["a"] is JsonObject aObj)
                        {
                            aObj["description"] = "First factor.";
                        }
                        if (properties["b"] is JsonObject bObj)
                        {
                            bObj["description"] = "Second factor.";
                        }
                    }
                    return JsonSerializer.SerializeToElement(node ?? JsonNode.Parse("{}"), HPDJsonContext.Default.JsonNode);
                 },
                ParameterDescriptions = new Dictionary<string, string> {
                    { "a", "First factor." },
                    { "b", "Second factor." }
                }
            }
        ));

        // Conditionally included functions
        if (EvaluateAbsCondition(context))
        {
            functions.Add(HPDAIFunctionFactory.Create(
                new Func<AIFunctionArguments, CancellationToken, Task<object?>>(async (arguments, cancellationToken) =>
                {
                    var jsonArgs = arguments.GetJson();
                    var args = ParseAbsArgs(jsonArgs);
                    return (await instance.Abs(args.Value)) as object;
                }),
                new HPDAIFunctionFactoryOptions
                { 
                    Name = "Abs",
                    Description = "Returns the absolute value. Only available if negatives are not allowed.",
                    RequiresPermission = false,
                    Validator = CreateAbsValidator(),
                    SchemaProvider = () => { 
                        var schema = new Json.Schema.JsonSchemaBuilder().FromType<AbsArgs>().Build();
                        var schemaJson = JsonSerializer.Serialize(schema, HPDJsonContext.Default.JsonSchema);
                        var node = JsonNode.Parse(schemaJson);
                        if (node is JsonObject root && root["properties"] is JsonObject properties)
                        {
                            if (properties["value"] is JsonObject valueObj)
                            {
                                valueObj["description"] = "Input value.";
                            }
                        }
                        return JsonSerializer.SerializeToElement(node ?? JsonNode.Parse("{}"), HPDJsonContext.Default.JsonNode);
                     },
                    ParameterDescriptions = new Dictionary<string, string> {
                        { "value", "Input value." }
                    }
                }
            ));
        }

        if (EvaluateSquareCondition(context))
        {
            functions.Add(HPDAIFunctionFactory.Create(
                new Func<AIFunctionArguments, CancellationToken, Task<object?>>(async (arguments, cancellationToken) =>
                {
                    var jsonArgs = arguments.GetJson();
                    var args = ParseSquareArgs(jsonArgs);
                    return (await instance.Square(args.Value)) as object;
                }),
                new HPDAIFunctionFactoryOptions
                { 
                    Name = "Square",
                    Description = "Squares a number. Only available if maxValue > 1000.",
                    RequiresPermission = false,
                    Validator = CreateSquareValidator(),
                    SchemaProvider = () => { 
                        var schema = new Json.Schema.JsonSchemaBuilder().FromType<SquareArgs>().Build();
                        var schemaJson = JsonSerializer.Serialize(schema, HPDJsonContext.Default.JsonSchema);
                        var node = JsonNode.Parse(schemaJson);
                        if (node is JsonObject root && root["properties"] is JsonObject properties)
                        {
                            if (properties["value"] is JsonObject valueObj)
                            {
                                valueObj["description"] = "Input value.";
                            }
                        }
                        return JsonSerializer.SerializeToElement(node ?? JsonNode.Parse("{}"), HPDJsonContext.Default.JsonNode);
                     },
                    ParameterDescriptions = new Dictionary<string, string> {
                        { "value", "Input value." }
                    }
                }
            ));
        }

        return functions;
    }

    private static Func<JsonElement, List<ValidationError>> CreateAddValidator()
    {
        return (jsonArgs) =>
        {
            var errors = new List<ValidationError>();
            try
            {
                var dto = ParseAddArgs(jsonArgs);
                if (dto.A == null)
                {
                    errors.Add(new ValidationError {
                        Property = "a",
                        ErrorMessage = "Property 'a' is required and cannot be null.",
                        ErrorCode = "missing_required_property"
                    });
                }
                if (dto.B == null)
                {
                    errors.Add(new ValidationError {
                        Property = "b",
                        ErrorMessage = "Property 'b' is required and cannot be null.",
                        ErrorCode = "missing_required_property"
                    });
                }
            }
            catch (JsonException ex)
            {
                string propertyName = ex.Path ?? "Unknown";
                errors.Add(new ValidationError { Property = propertyName, ErrorMessage = ex.Message, ErrorCode = "type_conversion_error" });
            }
            return errors;
        };
    }

    /// <summary>
    /// Manual JSON parser for AddArgs - fully AOT compatible
    /// </summary>
    private static AddArgs ParseAddArgs(JsonElement json)
    {
        var result = new AddArgs();

        // Parse a
        if (json.TryGetProperty("a", out var aProp) || 
            json.TryGetProperty("a", out aProp) ||
            json.TryGetProperty("a", out aProp))
        {
            result.A = aProp.GetDecimal();
        }
        else
        {
            throw new JsonException($"Required property 'a' not found");
        }

        // Parse b
        if (json.TryGetProperty("b", out var bProp) || 
            json.TryGetProperty("b", out bProp) ||
            json.TryGetProperty("b", out bProp))
        {
            result.B = bProp.GetDecimal();
        }
        else
        {
            throw new JsonException($"Required property 'b' not found");
        }

        return result;
    }

    private static Func<JsonElement, List<ValidationError>> CreateMultiplyValidator()
    {
        return (jsonArgs) =>
        {
            var errors = new List<ValidationError>();
            try
            {
                var dto = ParseMultiplyArgs(jsonArgs);
                // Add validation as needed
            }
            catch (JsonException ex)
            {
                string propertyName = ex.Path ?? "Unknown";
                errors.Add(new ValidationError { Property = propertyName, ErrorMessage = ex.Message, ErrorCode = "type_conversion_error" });
            }
            return errors;
        };
    }

    /// <summary>
    /// Manual JSON parser for MultiplyArgs - fully AOT compatible
    /// </summary>
    private static MultiplyArgs ParseMultiplyArgs(JsonElement json)
    {
        var result = new MultiplyArgs();

        // Parse a
        if (json.TryGetProperty("a", out var aProp) || 
            json.TryGetProperty("a", out aProp) ||
            json.TryGetProperty("a", out aProp))
        {
            result.A = aProp.GetInt64();
        }
        else
        {
            throw new JsonException($"Required property 'a' not found");
        }

        // Parse b
        if (json.TryGetProperty("b", out var bProp) || 
            json.TryGetProperty("b", out bProp) ||
            json.TryGetProperty("b", out bProp))
        {
            result.B = bProp.GetInt64();
        }
        else
        {
            throw new JsonException($"Required property 'b' not found");
        }

        return result;
    }

    private static Func<JsonElement, List<ValidationError>> CreateAbsValidator()
    {
        return (jsonArgs) =>
        {
            var errors = new List<ValidationError>();
            try
            {
                var dto = ParseAbsArgs(jsonArgs);
                // Add validation as needed
            }
            catch (JsonException ex)
            {
                string propertyName = ex.Path ?? "Unknown";
                errors.Add(new ValidationError { Property = propertyName, ErrorMessage = ex.Message, ErrorCode = "type_conversion_error" });
            }
            return errors;
        };
    }

    /// <summary>
    /// Manual JSON parser for AbsArgs - fully AOT compatible
    /// </summary>
    private static AbsArgs ParseAbsArgs(JsonElement json)
    {
        var result = new AbsArgs();

        // Parse value
        if (json.TryGetProperty("value", out var valueProp) || 
            json.TryGetProperty("value", out valueProp) ||
            json.TryGetProperty("value", out valueProp))
        {
            result.Value = valueProp.GetInt64();
        }
        else
        {
            throw new JsonException($"Required property 'value' not found");
        }

        return result;
    }

    /// <summary>
    /// Evaluates whether function Abs should be included.
    /// Expression: AllowNegative == false
    /// </summary>
    private static bool EvaluateAbsCondition(IPluginMetadataContext? context)
    {
        if (context == null) return true;
        
        if (context is not MathPluginMetadataContext typedContext) return false;
        
        try
        {
            // Evaluating: AllowNegative == false
            return typedContext.AllowNegative == false;
        }
        catch (Exception ex)
        {
            // Log error for debugging: Expression 'AllowNegative == false' failed: {ex.Message}
            return false;
        }
    }

    /// <summary>
    /// Evaluates whether function Square should be included.
    /// Expression: MaxValue > 1000
    /// </summary>
    private static bool EvaluateSquareCondition(IPluginMetadataContext? context)
    {
        if (context == null) return true;
        
        if (context is not MathPluginMetadataContext typedContext) return false;
        
        try
        {
            // Evaluating: MaxValue > 1000
            return typedContext.MaxValue > 1000;
        }
        catch (Exception ex)
        {
            // Log error for debugging: Expression 'MaxValue > 1000' failed: {ex.Message}
            return false;
        }
    }
}